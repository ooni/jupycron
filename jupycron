#!/usr/bin/env python3
#
# jupycron
#
# Warning: malicious jupyter filenames might allow command injection
#
# jupycron itself runs as root but the notebooks are run as jupyter
# monitor with: sudo journalctl -f -u jupycron

from datetime import datetime
from pathlib import Path
from typing import Optional, List, Tuple, Dict
import hashlib
import json
import logging
import subprocess
import time

import jinja2  # debdeps: python3-jinja2

DEFAULT_NOTEBOOK_PATH = Path("/var/lib/jupyter/notebooks/")
DEFAULT_OUTPUT_PATH = Path("/var/lib/jupyter/notebooks/jupycron")
RUNTIME_LIMIT = 3600
MAXMEM = 1000
log = logging.getLogger("jupycron")
log.setLevel(logging.DEBUG)

try:
    from systemd.journal import JournalHandler

    log.addHandler(JournalHandler())
except ImportError:
    log.addHandler(logging.StreamHandler())

# fn -> timestamp, status, every, elapsed time
History = Dict[str, Tuple[str, str, str, float]]


def load_history() -> History:
    fn = DEFAULT_OUTPUT_PATH / ".history.json"
    try:
        with fn.open() as f:
            j = json.load(f)
        return j["notebooks"]
    except Exception:
        return {}


def save_history(history: History) -> None:
    fn = DEFAULT_OUTPUT_PATH / ".history.json"
    j = dict(notebooks=history)
    with fn.open("w") as f:
        json.dump(j, f)
    log.debug(f"{fn} written")


def extract_jupycron_conf(nb: Path) -> Optional[dict]:
    assert nb.is_file()
    # Hacky but fast extractor
    read_data = 0
    for line in nb.open("rb"):
        #       example:
        #       "# jupycron: {\"every\": \"60 min\"}\n",
        idx = line.find(b'"# jupycron:')
        if idx >= 0:
            try:
                line = line[idx:].strip()
                lb = line.find(b"{")
                rb = line.rfind(b"}")
                line = line[lb : rb + 1]
                line_str = line.decode("unicode_escape")
                return json.loads(line_str)
            except Exception:
                pass

        read_data += len(line)
        if read_data > 500_000:
            return None

    return None
    # cmd = ["jupyter-nbconvert", "--to", "python", "--stdout", nb.as_posix()]
    # py = subprocess.check_output(cmd, timeout=5)
    # out = py.decode().splitlines()
    # for li in out:
    #     if not li.startswith("# jupycron"):
    #         continue
    #     _1, _2, conf = li.split(None, 2)
    #     return json.loads(conf)


time_lookup = {
    "min": 1,
    "minute": 1,
    "hour": 60,
    "day": 1440,
    "week": 10080,
    "month": 43800.0,
}


def time_to_run(conf: dict) -> Tuple[bool, str]:
    try:
        every = conf.get("every", "")
        num, dimension = every.split()
        dimension = dimension.rstrip("s")
        minutes = int(float(num) * time_lookup[dimension])
    except Exception as e:
        log.debug(f"Error {e} Unable to parse: {every}")
        return False, "Parse error"
    flag = int(time.time() / 60) % minutes == 0
    return flag, every


def generate_unit_name(nb: Path) -> str:
    hash_ = nb.as_posix().encode()
    hash_str_ = hashlib.sha224(hash_).hexdigest()[:10]
    return nb.stem.replace(" ", "_") + "-" + hash_str_


def run_notebook(nb: Path, conf: dict) -> Tuple[str, float]:
    elapsed = 0.0
    htmlfn = nb.with_suffix(".html").as_posix()
    htmlfn = htmlfn.replace(
        DEFAULT_NOTEBOOK_PATH.as_posix(), DEFAULT_OUTPUT_PATH.as_posix()
    )
    unitname = generate_unit_name(nb)
    # maxruntimesec = min(conf.get("MaxRuntime", RUNTIME_LIMIT), RUNTIME_LIMIT)
    memorymax = min(conf.get("MaxMem", MAXMEM), MAXMEM)
    cmd = [
        "systemd-run",
        f"--unit={unitname}",
        "--collect",
        "--wait",
        # "--uid=jupyter",
        "--gid=jupyter",
        "--working-directory=/var/lib/jupyter/notebooks/",
        # "--scope",
        "-p",
        f"MemoryMax={memorymax}M",
        # "-p",
        # f"MaxRuntimeSec={maxruntimesec}",
        "--setenv=AUTORUN=1",
        "jupyter-nbconvert",
        "--execute",
        "--to",
        "html",
        "--allow-errors",
        f"--output={htmlfn}",
        nb.as_posix(),
    ]
    log.info(f"running {' '.join(cmd)}")
    try:
        t0 = time.perf_counter()
        p = subprocess.check_output(cmd, stderr=subprocess.PIPE, timeout=5)
        elapsed = time.perf_counter() - t0
        out = p.decode()
        log.info(f"{unitname} output:\n{out}")
        status = "success"
    except subprocess.CalledProcessError as e:
        log.info(f"Error in {unitname}. Output:\n{e.output.decode()}")
        status = "failed"

    log.info(f"{unitname} done")
    return (status, elapsed)


def list_ipynb_files() -> List[Path]:
    out = []
    for nb in DEFAULT_NOTEBOOK_PATH.glob("**/*autorun*.ipynb"):
        # Skip hidden files
        if any(p.startswith(".") for p in nb.parts):
            continue
        out.append(nb)

    return sorted(out)


def update_history(run_history: History, history: History) -> None:
    """Merges new events into history dict"""
    for nb in tuple(history.keys()):
        if nb not in run_history:
            log.debug(f"Discarding deleted notebook {nb}")
            history.pop(nb)

    for nb, data in run_history.items():
        (tstamp, status, every, elapsed) = data
        if status == "not_run" and nb in history:
            pass
        else:
            history[nb] = data


def generate_summary(history: History) -> None:
    env = jinja2.Environment()
    now = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
    tpl = env.from_string(
        """
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Jupycron summary</title>
  <style>
    table {
        margin: 2em;
        padding: 1em;
        font-family: sans-serif;
        min-width: 400px;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);
        border-spacing: 10px;
    }
    p#gen {
        padding-left: 20em;
    }
  </style>
</head>

<body>
  <table>
    <tr>
        <th>Status</th>
        <th>Last run time</th>
        <th>Interval</th>
        <th>Name</th>
        <th>Run duration</th>
    </tr>
    {% for nb, (tstamp, status, every, elapsed) in hist %}
    <tr>
      {% if status == 'success': %}
      <td>ðŸŸ¢</td>
      {% elif status == 'failed': %}
      <td>ðŸ”´</td>
      {% elif status == 'not_run': %}
      <td>âŒ›</td>
      {% else %}
      <td>ðŸ›‡</td>
      {% endif %}
      <td>{{ tstamp }}</td>
      <td>{{ every }}</td>
      <td><a href=/notebooks/notebooks/{{ nb }}>{{ nb }}</a>
      </td>
      <td>{{ elapsed|round(2) }}</td>
    </tr>
    {% endfor %}
  </table>
  <p id="gen">Generated at {{ now }}</p>
</body>
</html>
"""
    )
    html = tpl.render(hist=sorted(history.items()), now=now)
    fn = DEFAULT_OUTPUT_PATH / "summary.html"
    fn.write_text(html)
    log.debug(f"{fn} written")


def main() -> None:
    history = load_history()
    notebooks = list_ipynb_files()
    log.debug(f"Found {len(notebooks)} notebooks")
    run_history: History = {}  # fn -> timestamp, status, elapsed time
    for nb in notebooks:
        nb_rel = nb.relative_to(DEFAULT_NOTEBOOK_PATH)
        try:
            conf = extract_jupycron_conf(nb)
            tstamp = ""
            elapsed = 0.0
            if conf is None:
                log.debug(f"Not enabled {nb_rel}")
                status = "disabled"
                every = ""
            else:
                run_now, every = time_to_run(conf)
                if run_now:
                    tstamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M")
                    log.debug(f"Running     {nb_rel}")
                    status, elapsed = run_notebook(nb, conf)
                else:
                    log.debug(f"Not running {nb_rel}")
                    status = "not_run"

            run_history[nb_rel.as_posix()] = (tstamp, status, every, elapsed)

        except Exception as e:
            log.error(e)

    update_history(run_history, history)
    save_history(history)
    generate_summary(history)


if __name__ == "__main__":
    main()
